<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mansa's Marbles - 1.5cm Margin Layout</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a2e; color: white; font-family: Arial, sans-serif; }
        canvas { display: block; }
        #info { position: absolute; top: 10px; width: 100%; text-align: center; z-index: 10; }
        #status { position: absolute; bottom: 10px; left: 10px; background: rgba(0,0,0,0.6); padding: 8px; border-radius: 4px; max-width: 450px; z-index: 10; max-height: 120px; overflow-y: auto; font-size: 11px; }
        .debug { color: #ff9900; }
    </style>
</head>
<body>
    <div id="info">Mansa's Marbles - Oware Board (1.5cm Margin Layout)<br/>(Drag to rotate, Scroll to zoom)</div>
    <div id="status">Loading...</div>
    
    <script>
        // Direct inline script
        let status = document.getElementById('status');
        
        function log(message) {
            console.log(message);
            status.innerHTML += `<div>${message}</div>`;
            status.scrollTop = status.scrollHeight;
        }
        
        function logError(message) {
            console.error(message);
            status.innerHTML += `<div class="debug" style="color: #ff4444;">${message}</div>`;
            status.scrollTop = status.scrollHeight;
        }
        
        // Load Three.js from CDN
        function loadScript(url) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = url;
                script.onload = resolve;
                script.onerror = () => reject(new Error(`Failed to load script: ${url}`));
                document.head.appendChild(script);
            });
        }
        
        async function initApp() {
            try {
                log("Loading Three.js...");
                await loadScript('https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js');
                log("Loading OrbitControls...");
                await loadScript('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js');
                log("Setup complete. Initializing scene...");
                initScene();
            } catch (error) {
                logError(`Load Error: ${error.message}`);
            }
        }
        
        function initScene() {
            // --- Board Configuration (Final Proportions, 1.5cm Margin & Handle Gap) ---
            const BOARD_CONFIG = {
                length: 45.0, width: 13.8, depth: 4, cornerRadius: 2.0, // Final board length
                margin: 1.5, 
                pitRows: 2, pitsPerRow: 6,
                pitRadius: 2.5, // Calculated pit radius (PD=5.0)
                pitDepth: 1.0, // Kept original depth
                handleCutoutWidth: 2.5, // Final handle width
                handleCutoutLength: 10.8, // Adjusted handle length for new board width
                handleCutoutCornerRadius: 1.25, // Final handle radius (width/2)
                handleDistanceFromEnd: 1.5, // Positioned at margin
                boardColor: 0xf5e8c0, pitColor: 0xd3c8a0,
                handlePitGap: 1.5, // Gap between handle and first pit column
                pitPitGap: 0.8 // Gap between pit columns
            };
            log(`Config: L=${BOARD_CONFIG.length}, W=${BOARD_CONFIG.width}, M=${BOARD_CONFIG.margin}, PR=${BOARD_CONFIG.pitRadius}, HW=${BOARD_CONFIG.handleCutoutWidth}, HL=${BOARD_CONFIG.handleCutoutLength}, HandleGap=${BOARD_CONFIG.handlePitGap.toFixed(2)}, PitGap=${BOARD_CONFIG.pitPitGap.toFixed(2)}`);

            // Scene setup
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            
            // Camera
            const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 35, 35);
            camera.lookAt(0, 0, 0);
            
            // Renderer
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            // Controls
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;
            
            // Lighting
            const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.7);
            scene.add(hemisphereLight);
            const keyLight = new THREE.DirectionalLight(0xffffff, 1.0);
            keyLight.position.set(15, 25, 20);
            keyLight.castShadow = true;
            keyLight.shadow.mapSize.width = 2048; keyLight.shadow.mapSize.height = 2048;
            scene.add(keyLight);
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.5);
            fillLight.position.set(-15, 15, -15);
            scene.add(fillLight);
            
            // Ground plane
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x2a2a4a, roughness: 0.8 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -BOARD_CONFIG.depth / 2 - 0.1;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Grid helper
            const gridHelper = new THREE.GridHelper(100, 20, 0x444444, 0x222222);
            gridHelper.position.y = -BOARD_CONFIG.depth / 2;
            scene.add(gridHelper);
            
            log("Creating Oware board...");
            
            try {
                const board = createOwareBoard(BOARD_CONFIG);
                scene.add(board);
                log("Board created.");
            } catch (error) {
                logError(`Create Error: ${error.message}`);
                logError(error.stack);
            }
            
            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            animate();
        }
        
        // Create complete Oware board
        function createOwareBoard(cfg) {
            const boardGroup = new THREE.Group();
            const halfBoardLength = cfg.length / 2;
            const halfBoardWidth = cfg.width / 2;
            
            // Materials
            const boardMaterial = new THREE.MeshStandardMaterial({ color: cfg.boardColor, roughness: 0.7 });
            
            log("Creating board shape w/ refined handle & pit holes...");
            
            // --- Main Board Shape (Handles and Pits as Holes) ---
            const boardShape = new THREE.Shape();
            const hw = halfBoardLength; const hh = halfBoardWidth; const r = cfg.cornerRadius;
            boardShape.moveTo(-hw + r, -hh); // Bottom left corner start
            boardShape.lineTo( hw - r, -hh); // Bottom edge
            boardShape.quadraticCurveTo( hw, -hh, hw, -hh + r); // Bottom right corner
            boardShape.lineTo( hw,  hh - r); // Right edge
            boardShape.quadraticCurveTo( hw,  hh, hw - r,  hh); // Top right corner
            boardShape.lineTo(-hw + r,  hh); // Top edge
            boardShape.quadraticCurveTo(-hw,  hh,-hw,  hh - r); // Top left corner
            boardShape.lineTo(-hw, -hh + r); // Left edge
            boardShape.quadraticCurveTo(-hw, -hh,-hw + r, -hh); // Back to start (bottom left corner)
            
            // Handles
            const handleHoles = [];
            const handleHalfLength = cfg.handleCutoutLength / 2; // 10.8 / 2 = 5.4
            const handleHalfWidth = cfg.handleCutoutWidth / 2;   // 2.5 / 2 = 1.25
            const handleR = cfg.handleCutoutCornerRadius;       // 1.25
            
            // Handle 1 (Right Side)
            const handlePath1 = new THREE.Path();
            const handleCenterX1 = hw - cfg.handleDistanceFromEnd - handleHalfWidth; // 22.5 - 1.5 - 1.25 = 19.75
            handlePath1.moveTo(handleCenterX1 - handleHalfWidth + handleR, -handleHalfLength);
            handlePath1.lineTo(handleCenterX1 + handleHalfWidth - handleR, -handleHalfLength);
            handlePath1.quadraticCurveTo(handleCenterX1 + handleHalfWidth, -handleHalfLength, handleCenterX1 + handleHalfWidth, -handleHalfLength + handleR);
            handlePath1.lineTo(handleCenterX1 + handleHalfWidth, handleHalfLength - handleR);
            handlePath1.quadraticCurveTo(handleCenterX1 + handleHalfWidth, handleHalfLength, handleCenterX1 + handleHalfWidth - handleR, handleHalfLength);
            handlePath1.lineTo(handleCenterX1 - handleHalfWidth + handleR, handleHalfLength);
            handlePath1.quadraticCurveTo(handleCenterX1 - handleHalfWidth, handleHalfLength, handleCenterX1 - handleHalfWidth, handleHalfLength - handleR);
            handlePath1.lineTo(handleCenterX1 - handleHalfWidth, -handleHalfLength + handleR);
            handlePath1.quadraticCurveTo(handleCenterX1 - handleHalfWidth, -handleHalfLength, handleCenterX1 - handleHalfWidth + handleR, -handleHalfLength);
            handleHoles.push(handlePath1);
            
            // Handle 2 (Left Side)
            const handlePath2 = new THREE.Path();
            const handleCenterX2 = -hw + cfg.handleDistanceFromEnd + handleHalfWidth; // -22.5 + 1.5 + 1.25 = -19.75
            handlePath2.moveTo(handleCenterX2 - handleHalfWidth + handleR, -handleHalfLength);
            handlePath2.lineTo(handleCenterX2 + handleHalfWidth - handleR, -handleHalfLength);
            handlePath2.quadraticCurveTo(handleCenterX2 + handleHalfWidth, -handleHalfLength, handleCenterX2 + handleHalfWidth, -handleHalfLength + handleR);
            handlePath2.lineTo(handleCenterX2 + handleHalfWidth, handleHalfLength - handleR);
            handlePath2.quadraticCurveTo(handleCenterX2 + handleHalfWidth, handleHalfLength, handleCenterX2 + handleHalfWidth - handleR, handleHalfLength);
            handlePath2.lineTo(handleCenterX2 - handleHalfWidth + handleR, handleHalfLength);
            handlePath2.quadraticCurveTo(handleCenterX2 - handleHalfWidth, handleHalfLength, handleCenterX2 - handleHalfWidth, handleHalfLength - handleR);
            handlePath2.lineTo(handleCenterX2 - handleHalfWidth, -handleHalfLength + handleR);
            handlePath2.quadraticCurveTo(handleCenterX2 - handleHalfWidth, -handleHalfLength, handleCenterX2 - handleHalfWidth + handleR, -handleHalfLength);
            handleHoles.push(handlePath2);
            
            // --- Calculate Pit Positions --- 
            const pitPositions = [];
            const pitRadius = cfg.pitRadius;
            const pitDiameter = pitRadius * 2;
            const pitSpacingX = pitDiameter + cfg.pitPitGap; // 5.0 + 0.8 = 5.8
            
            // Z positions for rows
            const rowZ1 = -halfBoardWidth + cfg.margin + pitRadius; // -6.9 + 1.5 + 2.5 = -2.9
            const rowZ2 = halfBoardWidth - cfg.margin - pitRadius;  //  6.9 - 1.5 - 2.5 =  2.9
            const rowZs = [rowZ1, rowZ2];
            
            // Starting X position
            const firstPitX = -halfBoardLength + cfg.margin + cfg.handleCutoutWidth + cfg.handlePitGap + pitRadius; // -22.5 + 1.5 + 2.5 + 1.5 + 2.5 = -14.5
            log(`First pit X: ${firstPitX.toFixed(2)}, Pit Spacing: ${pitSpacingX.toFixed(2)}`);

            for (let i = 0; i < cfg.pitRows; i++) {
                for (let j = 0; j < cfg.pitsPerRow; j++) {
                    const posX = firstPitX + j * pitSpacingX;
                    const posZ = rowZs[i];
                    pitPositions.push({ x: posX, z: posZ });
                }
            }
            
            // Create Pit Holes
            const pitHoles = [];
            for (let i = 0; i < pitPositions.length; i++) {
                const pos = pitPositions[i];
                const pitPath = new THREE.Path();
                pitPath.absarc(pos.x, pos.z, cfg.pitRadius, 0, Math.PI * 2, false);
                pitHoles.push(pitPath);
            }

            boardShape.holes.push(...handleHoles, ...pitHoles);
            log(`Added ${handleHoles.length} handle holes and ${pitHoles.length} pit holes.`);
            
            // Extrude the board shape (with all holes)
            const extrudeSettings = {
                steps: 1, depth: cfg.depth, bevelEnabled: true,
                bevelThickness: 0.1, bevelSize: 0.1, bevelOffset: 0, bevelSegments: 3
            };
            const boardGeometry = new THREE.ExtrudeGeometry(boardShape, extrudeSettings);
            
            const boardMesh = new THREE.Mesh(boardGeometry, boardMaterial);
            // Center the geometry manually for correct pit placement
            boardGeometry.computeBoundingBox();
            const center = new THREE.Vector3();
            boardGeometry.boundingBox.getCenter(center);
            boardMesh.position.sub(center);
            boardMesh.rotation.x = -Math.PI / 2; // Rotate to lay flat
            boardMesh.castShadow = true;
            boardMesh.receiveShadow = true;
            boardGroup.add(boardMesh);
            
            // Position board group correctly
            boardGroup.position.y = 0; // Position bottom of board near y=0
            
            log("Board setup complete.");
            return boardGroup;
        }
        
        // Start the app
        initApp();
    </script>
</body>
</html>
